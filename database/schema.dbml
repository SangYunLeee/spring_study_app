// DB 명세 (Single Source of Truth)
// dbdiagram.io에서 시각화: https://dbdiagram.io/d
//
// 워크플로우:
// 1. 이 파일 수정 (DBML)
// 2. ./scripts/generate-migration.sh (SQL 생성)
// 3. dbmate up (마이그레이션 실행)

Project springbasic {
  database_type: 'PostgreSQL'
  Note: '''
    # Spring Basic Application Database

    명세 우선 개발 (Spec-First Development)
    - API: OpenAPI 3.0
    - DB: DBML (Database Markup Language)
  '''
}

// ========================================
// 사용자 (Users)
// ========================================

Table users {
  id bigserial [pk, increment, note: '사용자 고유 ID (자동 증가)']
  name varchar(100) [not null, note: '사용자 이름']
  email varchar(255) [not null, unique, note: '이메일 주소 (로그인 ID, 중복 불가)']
  age integer [not null, note: '나이']
  created_at timestamp [not null, default: `CURRENT_TIMESTAMP`, note: '생성 일시']
  updated_at timestamp [not null, default: `CURRENT_TIMESTAMP`, note: '수정 일시']

  indexes {
    email [name: 'idx_users_email', note: '이메일 검색 성능 향상']
  }

  Note: '''
    사용자 테이블

    비즈니스 규칙:
    - email은 unique (중복 불가)
    - age는 0 이상

    API 매핑:
    - GET /api/users
    - POST /api/users
    - GET /api/users/{id}
    - PUT /api/users/{id}
    - DELETE /api/users/{id}
  '''
}

// ========================================
// 게시글 (Posts)
// ========================================

Table posts {
  id bigserial [pk, increment, note: '게시글 고유 ID (자동 증가)']
  title varchar(200) [not null, note: '게시글 제목']
  content text [not null, note: '게시글 내용']
  user_id bigint [not null, ref: > users.id, note: '작성자 ID (외래 키)']
  created_at timestamp [not null, default: `CURRENT_TIMESTAMP`, note: '생성 일시']
  updated_at timestamp [not null, default: `CURRENT_TIMESTAMP`, note: '수정 일시']

  indexes {
    user_id [name: 'idx_posts_user_id', note: '작성자별 게시글 조회']
    created_at [name: 'idx_posts_created_at', note: '최신 게시글 조회']
    (user_id, created_at) [name: 'idx_posts_user_created', note: '특정 사용자의 최신 게시글']
  }

  Note: '''
    게시글 테이블

    연관관계:
    - User (N:1) - 한 명의 User가 여러 Post 작성
    - Comment (1:N) - 하나의 Post에 여러 Comment

    비즈니스 규칙:
    - title은 200자 이하
    - content는 필수
    - 작성자(user_id)는 필수

    JPA 매핑:
    - @ManyToOne: Post → User (작성자)
    - @OneToMany: Post → Comment (댓글 목록)
    - FetchType.LAZY: 지연 로딩
  '''
}

// ========================================
// 댓글 (Comments)
// ========================================

Table comments {
  id bigserial [pk, increment, note: '댓글 고유 ID (자동 증가)']
  content text [not null, note: '댓글 내용']
  user_id bigint [not null, ref: > users.id, note: '작성자 ID (외래 키)']
  post_id bigint [not null, ref: > posts.id, note: '게시글 ID (외래 키)']
  created_at timestamp [not null, default: `CURRENT_TIMESTAMP`, note: '생성 일시']
  updated_at timestamp [not null, default: `CURRENT_TIMESTAMP`, note: '수정 일시']

  indexes {
    post_id [name: 'idx_comments_post_id', note: '게시글별 댓글 조회']
    user_id [name: 'idx_comments_user_id', note: '작성자별 댓글 조회']
    (post_id, created_at) [name: 'idx_comments_post_created', note: '특정 게시글의 최신 댓글']
    (post_id, user_id) [name: 'idx_comments_post_user', note: '특정 게시글의 특정 사용자 댓글']
  }

  Note: '''
    댓글 테이블

    연관관계:
    - User (N:1) - 한 명의 User가 여러 Comment 작성
    - Post (N:1) - 하나의 Post에 여러 Comment

    비즈니스 규칙:
    - content는 필수
    - 작성자(user_id)는 필수
    - 게시글(post_id)는 필수

    JPA 매핑:
    - @ManyToOne: Comment → User (작성자)
    - @ManyToOne: Comment → Post (게시글)
    - FetchType.LAZY: 지연 로딩
  '''
}

// ========================================
// 연관관계 다이어그램
// ========================================

// User (1) ────< (N) Post (1) ────< (N) Comment
//  작성자           게시글              댓글
//
// - 한 명의 User는 여러 Post를 작성
// - 하나의 Post는 여러 Comment를 가짐
// - 한 명의 User는 여러 Comment를 작성
